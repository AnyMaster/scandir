PEP: XXX
Title: os.scandir() function -- a better and faster directory iterator
Version: $Revision$
Last-Modified: $Date$
Author: Ben Hoyt <benhoyt@gmail.com>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 30-May-2014
Python-Version: 3.5
Post-History: ***


Abstract
========

This PEP proposes including a new directory iteration function,
``os.scandir()``, in the standard library. This new function adds
useful functionality and increases the speed of ``os.walk()`` by 2-10
times (depending on the platform and file system) by significantly
reducing the number of times ``stat()`` has to be called.


Rationale
=========

Python's built-in ``os.walk()`` is significantly slower than it needs
to be, because -- in addition to calling ``os.listdir()`` on each
directory -- it calls ``os.stat()`` on each file to determine whether
the filename is a directory or not. But both ``FindFirstFile`` /
``FindNextFile`` on Windows and `readdir` on Linux and OS X already
tell you whether the files returned are directories or not, so no
further ``stat`` system calls are needed. In short, you can reduce the number of system calls from about 2N to N, where N is the total number of files and directories in the tree.

**In practice, removing all those extra system calls makes
``os.walk()`` about 8-9 times as fast on Windows, and about 2-3
times as fast on Linux and Mac OS X.** So we're not talking about
micro-optimizations. See more benchmarks [TODO here].

Somewhat relatedly, many people [TODO] have also asked for a version of
``os.listdir()`` that yields filenames as it iterates instead of returning
them as one big list. This improves memory efficiency for iterating very large
directories.

So as well as providing a ``scandir()`` iterator function for other uses, Python's existing ``os.walk()`` function would be sped up a great deal.


Proposal for inclusion
======================

Specifically, this PEP proposes adding a single function to the ``os``
module in the standard library, ``scandir``, that takes a single,
optional string as its argument:

    scandir(path='.') -> generator of DirEntry objects

Just like ``os.listdir`` in Python 3.2+, ``path`` is optional and
defaults to the current directory. Like ``listdir``, ``scandir``
calls the OS's directory iteration system calls to get the names of
the files in ``path``, but is different from ``listdir`` in two
ways:

* Instead of bare filename strings, it returns lightweight
  ``DirEntry`` objects that hold the filename string and provide simple
  methods that allow access to the stat-like data that the OS
  returned.

* It returns a generator instead of a list, so that ``scandir`` acts
  as a true iterator instead of returning the full list immediately.

``scandir()`` yields a ``DirEntry`` for each file and directory in ``path``.
Just like ``listdir``, ``.`` and ``..`` are skipped, and the entries are yielded in system-dependent
order. Each ``DirEntry`` object has the following attributes and methods:

* ``name``: filename, relative to path (like that returned by ``os.listdir``)

* ``is_dir()``: like ``os.path.isdir()``, but requires no OS calls on most systems
  (Linux, Windows, OS X)

* ``is_file()``: like ``os.path.isfile()``, but requires no OS calls on most systems
  (Linux, Windows, OS X)

* ``is_symlink()``: like ``os.path.islink()``, but requires no OS calls on most
  systems (Linux, Windows, OS X)

* ``lstat()``: like os.lstat(), but requires no OS calls on Windows

The ``DirEntry`` attribute and method names were chosen to be the
same as those in the new ``pathlib`` module for consistency.


Note on caching
===============

The DirEntry objects are relatively dumb -- the ``name`` attribute is
obviously always cached, and the ``is_X`` and ``lstat`` methods cache
their values (immediately on Windows, on first use on Linux / OS X)
and never refetch from the system.

For this reason, DirEntry objects are intended to be used and thrown
away after iteration, not stored in long-lived data structured and
the methods called again and again.

If a user wants to do that (for example, for watching a file's size
change), they'll need to call the regular ``os.lstat()`` or
``os.path.getsize()`` functions which force a new OS call each time.


Examples
========

Here's a good usage pattern for ``scandir``. This is in fact almost
exactly how the scandir module's faster ``os.walk()`` implementation
uses it:

    dirs = []
    non_dirs = []
    for entry in scandir(path):
        if entry.is_dir():
            dirs.append(entry)
        else:
            non_dirs.append(entry)

Or, for getting the total size of files in a directory tree --
showing use of the ``DirEntry.lstat()`` method:

    def get_tree_size(path='.'):
        """Return total size of files in path and subdirs."""
        size = 0
        for entry in scandir.scandir(path):
            if entry.is_dir():
                sub_path = os.path.join(path, entry.name)
                size += get_tree_size(sub_path)
            else:
                size += entry.lstat().st_size
        return size

Note that ``get_tree_size()`` will get a huge speed boost on Windows,
because no extra stat call are needed, but on Linux and OS X the size
information is not returned by the directory iteration functions, so
this function won't gain anything there.


Use in the wild
===============

To date, ``scandir`` is definitely useful, but has been clearly marked
"beta", so it's uncertain how much use of it there is in the wild. Ben
Hoyt has definitely had several reports from people using it. For example:

* Chris F: "I am processing some pretty large directories and was half
  expecting to have to modify getdents. So thanks for saving me the effort."

* bschollnick: "I wanted to let you know about this, since I am using Scandir as a building block for this code. Here's a good example of scandir making a radical performance improvement over os.listdir." [TODO https://github.com/benhoyt/scandir/issues/19]

* Avram L: "I'm testing our scandir for a project I'm working on. Seems pretty solid, so first thing, just want to say nice work!"

Others have requested a PyPI package
for it, which has been created [TODO https://github.com/benhoyt/scandir/issues/12].

GitHub stats don't mean too much, but scandir does have several watchers,
issues, forks, etc. Here's the run-down as of the stats as of June 5, 2014:

* Watchers: 17
* Stars: 48
* Forks: 15
* Issues: 2 open, 19 closed

**However, the much larger point is this:**, if this PEP is accepted,
``os.walk()`` can easily be reimplemented using ``scandir`` rather than ``listdir`` + ``stat``,
increasing the speed of ``os.walk()`` very significantly. There are
thousands of developers, scripts, and production code that would benefit
from a very large speedup of ``os.walk()``. For example, on GitHub,
there are almost as many uses of os.walk (194,000) as there are of
os.mkdir (230,000).


Previous discussion
===================


Open issues and optional things
===============================

There are a few open issues or optional additions:


Should scandir be in its own module?
------------------------------------

Should the function be included in the standard library in a new module,
``scandir.scandir()``, or just as ``os.scandir()`` as discussed? The
preference of this PEP's author (Ben Hoyt) would be ``os.scandir()``,
as it's just a single function.


Should there be a way to access the full path?
----------------------------------------------

Should DirEntry's have a way to get the full path without using
``os.path.join(path, entry.name)``. This is a pretty common pattern,
and it may be useful to add pathlib-like ``str(entry)``
functionality. This functionality has also been requested in
`issue 13`_ on GitHub.

.. _`issue 13`: https://github.com/benhoyt/scandir/issues/13


Should it expose Windows wildcard functionality
-----------------------------------------------

Should ``scandir()`` have a way of exposing the wildcard functionality
in the Windows ``FindFirstFile`` / ``FindNextFile`` functions. The
scandir module exposes this as a ``windows_wildcard`` keyword argument,
allowing Windows power users to optionally pass a custom wildcard to
``FindFirstFile``, which may avoid the need to use ``fnmatch`` or similar
on the resulting names. It is named the unwieldly ``windows_wildcard``
to remind you you're writing power-user, Windows-only code if you use it.

This boils down to whether ``scandir`` should be about exposing the OS's
directory iteration features, or simply providing a fast, simple,
cross-platform directory iteration API.

This PEP's author votes for excluding ``windows_wildcard``, because even
though it could be useful in rare cases (say the Windows Dropbox client?),
it'd be too easy to use it just because you're a Windows developer,
and create code that is not cross-platform.


References
==========



Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
